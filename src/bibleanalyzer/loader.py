#
# Copyright (c) 2021 by Kristoffer Paulsson <kristoffer.paulsson@talenten.se>.
#
# Permission to use, copy, modify, and/or distribute this software for any purpose with
# or without fee is hereby granted, provided that the above copyright notice and this
# permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO
# THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO
# EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
# DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#
#     https://opensource.org/licenses/ISC
#
# SPDX-License-Identifier: ISC
#
# Contributors:
#     Kristoffer Paulsson - initial implementation
#
"""Corpus loader. Loads and parses UTF-8 corpus files as generated by the BibleWorks 10 Report Generator,
saved as RTF and converted to TXT by TextEdit for macOS."""
import re
from pathlib import Path

from . import Processor, ProcessException
from bibleanalyzer.app.logging import Logger
from bibleanalyzer.util.model import DataEntry, GreekWord
from .app import Application
from .util.reference import BibleReferenceCounter

VERSE_REGEX = r"""(?P<translation>\S+) (?P<book>\S+) (?P<chapter>\d+)\:(?P<verse>\d+) (?P<text>\S.*)"""
HLINE_REGEX = r"""^\.*\n(_+)\n.*$"""
GREEK_REGEX = r"""^(?:\d+)\. (?:\S+) (?:\S+) - (?:\S+) (?:\S+).*$"""
WHOLE_REGEX = r"""^(?:(?P<translation>\S+) (?P<book>(?:[1-3] )?[\S ]+) (?P<chapter>\d+)\:(?P<verse>\d+)(?: (?P<text>\S.*))?)|(?P<line>_+)|(?:(?P<index>\d+)\. (?P<word>\S+) (?P<lexeme>\S+) - (?P<grammar>\S+) (?P<inflexion>[\S ]+))$"""

TOKEN_REGEX = r"""([·.,;:]|[^[·\.,;: \(\)\[\]]\s]+)"""


class StateError(RuntimeWarning):
    """State machine throws this exception at wrongful attempt to change the state."""


class LoaderIterator:

    def __init__(self, filename: Path, translation: str):
        self._filename = filename
        self._translation = translation

        self._tasks = (
            None,
            self._start,
            self._text,
            self._line,
            self._word,
            self._end
        )

        self._logger = Application.instance().logger
        self._data = list()

        self._machine = None
        self._skip = False

        self._counter = None
        self._cur_book = None

        self._line_cnt = 0
        self._total_cnt = 0
        self._word_cnt = 1

        self._entry = None

    def _file_iter(self):
        with self._filename.open("r") as doc:
            for line in doc:
                self._line_cnt += 1
                match = re.match(WHOLE_REGEX, line)
                if match:
                    yield match.groupdict()

    def _proc_iter(self):
        self._logger.info("Load corpus: {}".format(self._filename.name))

        try:
            for line in self._file_iter():
                if not line:
                    continue

                self._switch(line)
                try:
                    self._tasks[self._machine.state](line)
                except ProcessException as e:
                    self._logger.error(Logger.file_format(e, self._filename, self._line_cnt))
                for entry in self._data:
                    yield entry
                self._data.clear()

            self._machine.goto(StateMachine.END)
            self._tasks[self._machine.state]()
            for entry in self._data:
                yield entry
            self._data.clear()
        except StateError as e:
            self._logger.error(Logger.file_format(
                "{} The parser suffered from a state machine error, skipping".format(e),
                self._filename, self._line_cnt
            ))

    def _switch(self, line: dict):
        self._logger.debug(list(filter(None, line.values())))

        # In case a verse has been left out we reset the state machine and start over.
        if line["translation"] and self._machine.state is StateMachine.LINE:
            self._data.append(self._entry)
            self._entry = None
            self._machine.reset()
            self._machine.goto(StateMachine.TEXT)

        elif line["translation"] and self._machine.state is not StateMachine.TEXT:
            if self._machine.state == StateMachine.WORD:
                self._data.append(self._entry)
                self._entry = None
            self._machine.goto(StateMachine.TEXT)
        elif line["line"] and self._machine.state is not StateMachine.LINE:
            self._machine.goto(StateMachine.LINE)
        elif line["index"] and self._machine.state is not StateMachine.WORD:
            self._machine.goto(StateMachine.WORD)
            self._word_cnt = 1

    def _start(self, line: dict):
        pass

    def _text(self, line: dict):
        if not line["translation"]:
            self._logger.error(Logger.file_format("Expected a translation", self._filename, self._line_cnt))
        elif line["translation"] != self._translation:
            return

        book = line["book"]
        chapter = int(line["chapter"])
        verse = int(line["verse"])

        if not line["text"]:
            self._skip = True
            self._logger.warning(
                Logger.file_format("{book} {chapter}:{verse} ({translation}) is missing in".format(
                    book=book, chapter=chapter, verse=verse, translation=line["translation"]),
                    self._filename, self._line_cnt, "corpus"
                )
            )

        if book:
            self._cur_book = book

        if chapter == self._counter.chapter + 1:
            self._counter.increase_chapter()
        else:
            if chapter != self._counter.chapter:
                self._logger.error(
                    Logger.file_format("Chapter is out of order ({}, {})".format(
                        self._counter.chapter, chapter), self._filename, self._line_cnt))
            if verse != self._counter.verse:
                self._logger.error(Logger.file_format(
                    "Verse is out of order ({}, {})".format(
                        self._counter.verse, verse), self._filename, self._line_cnt))

        self._entry = DataEntry(
            index=self._total_cnt,
            book=book,
            chapter=chapter,
            verse=verse,
            text=line["text"],
            translation=line["translation"]
        )
        self._counter.increase_verse()

    def _line(self, line: dict):
        if not line["line"]:
            self._logger.error(Logger.file_format("Expected a line", self._filename, self._line_cnt))

    def _word(self, line: dict):
        if not line["index"]:
            self._logger.error(Logger.file_format("Expected a greek word", self._filename, self._line_cnt))

        index = int(line["index"])

        if index != self._word_cnt:
            self._logger.error(
                Logger.file_format("Greek word not in order ({}, {})".format(
                    self._word_cnt, index), self._filename, self._line_cnt))

        self._entry.words.append(GreekWord(
            word=line["word"],
            lexeme=line["lexeme"],
            grammar=line["grammar"],
        ))
        self._word_cnt += 1
        self._total_cnt += 1

    def _end(self):
        self._data.append(self._entry)
        self._entry = None

    def __iter__(self):
        self._iter = self._proc_iter()
        self._machine = StateMachine()
        self._skip = False
        self._data = list()

        self._counter = BibleReferenceCounter()
        self._cur_book = None

        self._line_cnt = 0
        self._total_cnt = 0
        self._word_cnt = 1

        self._entry = None
        return self

    def __next__(self):
        entry = next(self._iter)
        if entry:
            return entry
        else:
            raise StopIteration()


class StateMachine:
    START = 1
    TEXT = 2
    LINE = 3
    WORD = 4
    END = 5

    def __init__(self):
        self._state = self.START
        self._states = {
            self.START: (self.TEXT,),
            self.TEXT: (self.LINE,),
            self.LINE: (self.WORD,),
            self.WORD: (self.END, self.TEXT),
            self.END: tuple(),
        }

    @property
    def state(self) -> int:
        return self._state

    def goto(self, state: int):
        if state not in self._states[self._state]:
            raise StateError("Couldn't go from state {} to {}".format(self._state, state))
        self._state = state

    def reset(self):
        self._state = self.START


class TextLoader(Processor):

    def __init__(self, logger: Logger, translation: str = None):
        self.logger = logger
        self._translation = translation
        self._data = list()
        self._verify = ""
        self._missing = list()

    @property
    def data(self) -> list:
        return self._data

    @property
    def verify(self) -> str:
        return self._verify.strip()

    @property
    def stats(self) -> dict:
        data = list()
        for entry in self.data:
            if entry.words:
                data.append(len(entry.words))
        return {"max": max(data), "min": min(data), "avg": sum(data) / len(data)}

    @property
    def telemetry(self) -> dict:
        return {
            "missing": self._missing,
            **self.stats
        }

    def process(self, filename: Path):
        for entry in LoaderIterator(filename, self._translation):
            self._add_data(entry)

    def _add_data(self, entry):
        if entry.text:
            self._verify += entry.text.strip() + "\n"
        self._data.append(entry)
